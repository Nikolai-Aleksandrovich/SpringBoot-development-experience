#### Spring 测试 Comments

* BootstrapWith:

  * 配置TestContext Framework

    

* ContextConfiguration:
  * 加载配置，确定如何加载和配置`ApplicationContext`以进行集成测试。
  * 也可以声明初始化类或者加载程序

* WebAppConfiguration
  * 确保为测试加载`WebApplicationContext`

* ContextHierarchy
  * 定义`ApplicationContext`实例的层次结构以进行集成测试

* ActiveProfiles
  * 声明在加载`ApplicationContext`进行集成测试时应激活哪些 bean 定义配置文件。
  * `@ActiveProfiles`默认情况下支持继承超类声明的活动 bean 定义配置文件。

* TestPropertySource
  * 配置属性文件和内联属性的位置，以将其添加到`Environment`中的`PropertySources`集合中，以便为集成测试加载`ApplicationContext`。
  * 测试属性源的优先级高于从 os 环境或 Java 系统属性以及应用程序通过`@PropertySource`或以编程方式添加的属性源加载的属性。可用来覆盖系统和应用程序编程方式加入的属性
  * 内联属性比资源位置加载的属性优先级更高

* @DirtiesContext
  * 表示基础 Spring `ApplicationContext`在执行测试期间已被弄脏，因此应将其关闭。会将其从测试框架的缓存中删除并关闭，将为需要上下文具有相同配置元数据的任何后续测试重建基础 Spring 容器。
  * 如果在测试中使用`@DirtiesContext`且上下文使用`@ContextHierarchy`配置为上下文层次结构的一部分，则可以使用`hierarchyMode`标志来控制如何清除上下文缓存，指定当前级别算法，而不是穷举算法
  * 穷举算法（默认）将公共祖先的所有子层次结构下的所有application Context删除，配置了当前级别算法，那就只删除当前级别。

##### 1.@BootstrapWith

@BootstrapWith`是类级别的 Comments，可用于配置如何引导 Spring TestContext Framework。具体来说，可以使用`@BootstrapWith`指定自定义`TestContextBootstrapper

##### 2.@ContextConfiguration

`@ContextConfiguration` defines class-level metadata that is used to determine how to load and configure an `ApplicationContext` for integration tests. 

Specifically, `@ContextConfiguration` declares the application context resource `locations` or the annotated `classes` used to load the context.

<u>Resource locations are typically XML configuration files or Groovy scripts located in the classpath,</u> while annotated classes are typically `@Configuration` classes. However, resource locations can also refer to files and scripts in the file system, and annotated classes can be component classes, and so on

- **(1)** Referring to an XML file.

example：`@ContextConfiguration` annotation that refers to an XML file:

```
@ContextConfiguration("/test-config.xml") 
public class XmlApplicationContextTests {
    // class body...
}
```

- **(2)** Referring to a class.

```
@ContextConfiguration(classes = TestConfig.class) 
public class ConfigClassApplicationContextTests {
    // class body...
}
```

- **(3)** Declaring an initializer class.

As an alternative or in addition to declaring resource locations or annotated classes, you can use `@ContextConfiguration` to declare `ApplicationContextInitializer` classes. 

```
@ContextConfiguration(initializers = CustomContextIntializer.class) 
public class ContextInitializerTests {
    // class body...
}
```

**(4)** Configuring both a location and a custom loader.

```
@ContextConfiguration(locations = "/test-context.xml", loader = CustomContextLoader.class)
public class CustomLoaderXmlApplicationContextTests {
    // class body...
}
```

##### @WebAppConfiguration

`@WebAppConfiguration` is a class-level annotation that you can use to declare that the `ApplicationContext` loaded for an integration test should be a `WebApplicationContext` . 

`@WebAppConfiguration`  ensures that a `WebApplicationContext` is loaded for the test, using the default value of `"file:src/main/webapp"` for the path to the root of the web application

The resource base path is used behind the scenes to create a `MockServletContext` , which serves as the `ServletContext` for the test’s `WebApplicationContext` .

- **(1)** The `@WebAppConfiguration` annotation.

```
@ContextConfiguration
@WebAppConfiguration 
public class WebAppTests {
    // class body...
}
```

To override the default, you can specify a different base resource path by using the implicit `value` attribute. Both `classpath:` and `file:` resource prefixes are supported. If no resource prefix is supplied, the path is assumed to be a file system resource. The following example shows how to specify a classpath resource:

- **(2)** Specifying a classpath resource.

```
@ContextConfiguration
@WebAppConfiguration("classpath:test-web-resources") 
public class WebAppTests {
    // class body...
}
```

Note that `@WebAppConfiguration` must be used in conjunction with `@ContextConfiguration` , either within a single test class or within a test class hierarchy. 

##### @ContextHierarchy

`@ContextHierarchy` is a class-level annotation that is used to define a hierarchy of `ApplicationContext` instances for integration tests. `@ContextHierarchy` should be declared with a list of one or more `@ContextConfiguration` instances, each of which defines a level in the context hierarchy. The following examples demonstrate the use of `@ContextHierarchy` within a single test class ( `@ContextHierarchy` can also be used within a test class hierarchy):

```
@ContextHierarchy({
    @ContextConfiguration("/parent-config.xml"),
    @ContextConfiguration("/child-config.xml")
})
public class ContextHierarchyTests {
    // class body...
}
```

```
@WebAppConfiguration
@ContextHierarchy({
    @ContextConfiguration(classes = AppConfig.class),
    @ContextConfiguration(classes = WebConfig.class)
})
public class WebIntegrationTests {
    // class body...
}
```

If you need to merge or override the configuration for a given level of the context hierarchy within a test class hierarchy, you must explicitly name that level by supplying the same value to the `name` attribute in `@ContextConfiguration` at each corresponding level in the class hierarchy. 

##### @ActiveProfiles

`@ActiveProfiles` is a class-level annotation that is used to declare which bean definition profiles should be active when loading an `ApplicationContext` for an integration test.

- **(1)** Indicate that the `dev` profile should be active.

```
@ContextConfiguration
@ActiveProfiles("dev") 
public class DeveloperTests {
    // class body...
}
```

- **(2)** Indicate that the `dev` and `integration` profiles should be active.

```
@ContextConfiguration
@ActiveProfiles({"dev", "integration"}) 
public class DeveloperIntegrationTests {
    // class body...
}
```

##### @TestPropertySource

`@TestPropertySource` is a class-level annotation that you can use to configure the locations of properties files and inlined properties to be added to the set of `PropertySources` in the `Environment` for an `ApplicationContext` loaded for an integration test.

Test property sources have higher precedence than those loaded from the operating system’s environment or Java system properties as well as property sources added by the application declaratively through `@PropertySource` or programmatically.

 test property sources can be used to selectively override properties defined in system and application property sources. 

 inlined properties have higher precedence than properties loaded from resource locations.

- **(1)** Get properties from `test.properties` in the root of the classpath.

```
@ContextConfiguration
@TestPropertySource("/test.properties") 
public class MyIntegrationTests {
    // class body...
}
```

- **(1)** Declare `timezone` and `port` properties.

  declare inlined properties:

```
@ContextConfiguration
@TestPropertySource(properties = { "timezone = GMT", "port: 4242" }) (1)
public class MyIntegrationTests {
    // class body...
}
```

##### @DirtiesContext

`@DirtiesContext` indicates that the underlying Spring `ApplicationContext` has been dirtied during the execution of a test (that is, the test modified or corrupted it in some manner — for example, by changing the state of a singleton bean) and should be closed. When an application context is marked as dirty, it is removed from the testing framework’s cache and closed. As a consequence, the underlying Spring container is rebuilt for any subsequent test that requires a context with the same configuration metadata.

You can use `@DirtiesContext` as both a class-level and a method-level annotation within the same class or class hierarchy. In such scenarios, the `ApplicationContext` is marked as dirty before or after any such annotated method as well as before or after the current test class, depending on the configured `methodMode` and `classMode` .

**(1)** Dirty the context before the current test class.

Before the current test class, when declared on a class with class mode set to `BEFORE_CLASS` 

```
@DirtiesContext(classMode = BEFORE_CLASS) (1)
public class FreshContextTests {
    // some tests that require a new Spring container
}
```

**(2)** Dirty the context after the current test class.

```
@DirtiesContext 
public class ContextDirtyingTests {
    // some tests that result in the Spring container being dirtied
}
```

**(3)** Dirty the context before each test method.

```
@DirtiesContext(classMode = BEFORE_EACH_TEST_METHOD) (1)
public class FreshContextTests {
    // some tests that require a new Spring container
}
```

**(4)** Dirty the context after each test method.

```
@DirtiesContext(classMode = AFTER_EACH_TEST_METHOD) (1)
public class ContextDirtyingTests {
    // some tests that result in the Spring container being dirtied
}
```

**(5)** Dirty the context before the current test method.

```
@DirtiesContext(methodMode = BEFORE_METHOD) (1)
@Test
public void testProcessWhichRequiresFreshAppCtx() {
    // some logic that requires a new Spring container
}
```

**(6)** Dirty the context after the current test method.

```
@DirtiesContext (1)
@Test
public void testProcessWhichDirtiesAppCtx() {
    // some logic that results in the Spring container being dirtied
}
```

**(7)** 使用当前级别的算法。

```
@ContextHierarchy({
    @ContextConfiguration("/parent-config.xml"),
    @ContextConfiguration("/child-config.xml")
})
public class BaseTests {
    // class body...
}

public class ExtendedTests extends BaseTests {

    @Test
    @DirtiesContext(hierarchyMode = CURRENT_LEVEL) 
    public void test() {
        // some logic that results in the child context being dirtied
    }
}
```

##### @TestExecutionListeners