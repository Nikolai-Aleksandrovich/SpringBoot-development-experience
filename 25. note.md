#### 方法重载满足的条件  ：

* 1. 同一个类中，方法名相同，参数列表不同的2个或多个方法构成方法的重载  
  2. 参数列表不同指参数的类型，参数的个数，参数的顺序至少一项不同   
  3. 方法的返回值类型，方法的修饰符可以不同。

#### 访问说明符：

![图片说明](https://uploadfiles.nowcoder.com/images/20170711/6863719_1499741731233_5F07387D61B2FE3164FB8B079FE0376B)

#### 一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：

1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。

2）禁止进行指令重排序。

volatile只提供了保证访问该变量时，每次都是从内存中读取最新值，并不会使用寄存器缓存该值——每次都会从内存中读取。

而对该变量的修改，volatile并不提供原子性的保证。

由于及时更新，很可能导致另一线程访问最新变量值，无法跳出循环的情况

多线程下计数器必须使用锁保护。

#### 为什么会出现4.0-3.6=0.40000001这种现象？

**浮点数值采用二进制系统表示， 而在二进制系统中无法精确地表示分数 1/10。
这 就好像十进制无法精确地表示分数 1/3—样。
如果在数值计算中不允许有任何舍入误差， 就应该使用 BigDecimal类。**

